Yast architecture
=================
:toc:

In order to be proficient with Yast development it's necessary to have a clear
view on how the Yast world is structured. The goal of this document is to
provide that view in a concise way, mentioning all the pieces and exposing how
they fit together. For a more detailed view about any of the technologies or
components, refer to the corresponding documentation linked from the central
documentation page for Yast at http://yast.github.io/.

Overview
--------

Yast has been invented to have an extensible and fairly standardized
means to install and manage Linux on a system. Basically Yast serves three
main purposes:

* Installation of Linux on a system
* Configuration of the installed system
* Administration of the installed system

From the point of view of software architecture, Yast is mainly a component
system in which the different pieces, that can be implemented in several
programming languages, interface with each other using a specific
protocol called YCP (Yast Communication Protocol). There are mainly two kind
of components: those providing functionality to others and the so-called
clients. The former ones publish a YCP interface with useful functions and
variables. On the other hand, a client always serves a concrete purpose and
controls the execution work-flow. Clients rely on other components (including
other clients) to get the job done. Therefore, executing Yast means actually
calling a Yast client.

A the time of writing, Yast components can be written in C++ (using liby2 and
libycp), in Ruby (using yast-ruby-bindings) and in Perl (using
yast-perl-bindings). Ruby is the preferred and recommended way, since the
bindings offer some unique features for both implementation and testing. In
addition, many development tasks are automated using the Ruby toolchain.

Main components
---------------

There are several components that have a very relevant role in Yast and must be
known in order to understand the "big picture". As already outlined in the
previous section, there are mainly two kind of components:

* Components providing functionality to others
  - SCR: system configuration repository
  - WFM: work-flow manager
  - UI: user interface
  - Modules
* Clients

image:images/yast-components.png[The Yast Architecture]

System Configuration repository (SCR)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All the communication with the underlying system being
installed or configured is handled by a component called SCR (for System
Configuration Repository). SCR is composed of several subcomponents called
agents. Each agent takes care of a very concrete type of system resource and
implements a common interface with just three operations: read, write and
execute.

Work-flow manager (WFM)
~~~~~~~~~~~~~~~~~~~~~~~

The Yast work-flow manager (implemented in the WFM namespace) is a special
component which takes care of executing clients and providing to them the
interface with the other components. It's also responsible of handling one
SCR instance per every system that is being managed by Yast.

Despite being quite lightweight, WFM can be considered as the
core engine of Yast, since every Yast execution starts with WFM handing the
control over a client after having connected it to the user interface and a
SCR instance.

User interface
~~~~~~~~~~~~~~

Given the wide variety of machines and use cases that can possibly be
handled with Yast, the UI component provides a very convenient abstraction layer
for the user interface. Very much like the SCR, the UI does not necessarily run
on the installation target machine. It doesn't even need to run on the same
machine as the WFM.

The UI component is usually referred as "UI bindings" since it basically offers
a YCP interface on top of *libyui*, the programming library actually implementing
the different "widgets": user interface elements such as
input fields, selection lists or buttons. It is transparent to the
calling application if those widgets are part of a graphical toolkit
such as Qt or Gtk+, a text based interface using the Ncurses library or even
something else not implemented yet.

Modules
~~~~~~~

Apart from the already mentioned few components with very special roles and the
clients, Yast also consists on a huge amount of other components called modules
and used to encapsulate functionality related to different areas. Examples of
available modules are Network, Service, FileSystem or PulseAudio.

Some notes about the Yast Communication Protocol (YCP)
------------------------------------------------------

All communication between the different parts of YaST core is done via a
predefined set of YCP data types - simple data types like string,
integer, boolean etc., but also compound data types like maps (key /
value pairs, also known as "hashes" in other programming languages) or
lists (like arrays or vectors in other programming languages). For
complex data structures, maps, lists and simple data types can be nested
to any degree.

TODO:

* ycp terms
* ycp paths
* import and include (probably better explained in ruby-binding docs)

